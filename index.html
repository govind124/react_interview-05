<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>react-interview-05</title>
    <link rel="Icon" href="./redux flow.png">
    <style>
        body{
            background-color: brown;
            color: white;
        }
        p{
            font-size: 20px;
        }
        pre{
            font-size: 15px;
        }
        h1{
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>React_Interview_prepration-05</h1>

    <h2>Q.1 High Order Component in react js ?</h2><br>
    <p>Ans--A higher-order component is a function that takes a component and returns a new component. A higher-order component (HOC) is the advanced technique in React.js for reusing a component logic. Higher-Order Components are not part of the React API. They are the pattern that emerges from React’s compositional nature. The component transforms props into UI, and a higher-order component converts a component into another component. The examples of HOCs are Redux’s connect and Relay’s createContainer.</p><br>
    <pre>import React, {Component} from 'react';  
  
        export default function Hoc(HocComponent){  
            return class extends Component{  
                render(){  
                    return (  
                        <div>  
                            <HocComponent></HocComponent>  
                        </div>  
          
                    );  
                }  
            }   
        }  </pre><br>
    <h2>Q.2 Do you know about SEO ? Is it true that react js supports SEO support ?</h2><br>
    <p>--SEO stands for Search Engine Optimization. The goal of SEO is to create a strategy that will increase your rankings position in search engine results. The higher the ranking, the more organic traffic to your site, which ultimately leads to more business for you!</p><br>
    <p>--you use React without server-side rendering is that the crawler halts on the very first page because it can’t see any hyperlinks to follow. It sends the page to the indexer, which then has to render the page and extracts the hyperlinks, which will then be added to the crawler’s queue. Then the crawler will eventually crawl the next set of pages, and again will stop there because all the links are invisible until the JavaScript is rendered. </p><br>
    <h2>Q.3 clean up in useEffect ?</h2><br>
    <p>Ans--The useEffect hook is built in a way that if we return a function within the method, this function will execute when the component gets disassociated. This is very useful because we can use it to remove unnecessary behavior or prevent memory leaking issues.</p><br>
    <pre>Ex--
        useEffect(() => {
        API.subscribe()
        return function cleanup() {
            API.unsubscribe()
        }
    })</pre><br>
   <h2>Q.4 What is the use of useCallback and useMemo? </h2>
   <p>useCallback--UseCallback is used to optimize the rendering behavior of your React function components, while useMemo is used to memoize expensive functions to avoid having to call them on every render. As a standard construction of hooks, those two solutions are not so different. Like with useEffect, a hook that manages the side-effects in functional components, argument callback comes first and then an array of dependencies.</p>
   <pre>function callbackUsed() {
    const _  = useCallback(() => {
      return ‘insert JSX here’
    })
  
    return _()
      }</pre><br>
    <p>The useMemo is similar to useCallback hook as it accepts a function and a list of dependencies but it returns the memoized value returned by the passed function. It recalculated the value only when one of its dependencies change. It is useful to avoid expensive calculations on every render when the returned value is not going to change.</p>
    <pre>Ex--const numPlusFive = useMemo(() => plusFive(num), [num]);</pre><br>
    <h2>Q.5 Why do we need keys in react less ?</h2>
    <p>Ans-- Keys should be a unique identifier so that each element can be identified properly. Hence, it is recommended to use some uniquely generated id as the key. You can even assign keys to a dynamically rendered list.</p>
    <pre>const todoItems = todos.map((todo) =>
         key={todo.id}>
          {todo.text}
        
      );
      </pre><br>
    <h2>Q.6 Do you know about redux?</h2>
    <p>Ans--Redux is a pattern and library for managing and updating application state, using events called "actions". It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.Redux is a predictable state container for JavaScript apps. As the application grows, it becomes difficult to keep it organized and maintain data flow. Redux solves this problem by managing application’s state with a single global object called Store. Redux fundamental principles help in maintaining consistency throughout your application, which makes debugging and testing easier</p>
    <img src="./redux flow.png" alt="">
</body>
</html>